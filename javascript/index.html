<html>
  <head>
    <script type="text/javascript" src="js/hardware.js"></script>
    <script language="javascript" type="text/javascript">
    rom = {
      name: "PONG"
      , data: "6a026b0c6c3f6d0ca2eadab6dcd66e0022d4660368026060f015f0073000121ac717770869ffa2f0d671a2eadab6dcd66001e0a17bfe6004e0a17b02601f8b02dab6600ce0a17dfe600de0a17d02601f8d02dcd6a2f0d67186848794603f8602611f871246021278463f1282471f69ff47006901d671122a68026301807080b5128a68fe630a807080d53f0112a2610280153f0112ba80153f0112c880153f0112c26020f01822d48e3422d4663e3301660368fe33016802121679ff49fe69ff12c87901490269016004f0187601464076fe126ca2f2fe33f265f12964146500d4557415f229d45500ee808080808080800000000000"
    }

    memory   = Array.apply(null, {length: 4096});

    var cpu = {
      type: 'chip8',
      // CHIP-8 allows for the usage of sixteen eight-bit general purpose registers capable of storing
      // unsigned integers between decimal 0 and 255, or hexadecimal 00 to FF.
      // These registers are referred to as V0 to VF, one for each hexadecimal digit.
      // Any register can be used for data manipulation, but it should be noted that the VF register is often
      // modified by certain instructions to act as a flag.
      register: new Int16Array(16),
      // I Register - In order to specify the memory addresses containing the data for a given sprite,
      // there must be some way to store an address for later use. The sixteen data registers (V0 - VF)
      // provided by CHIP-8 are only eight bits in length, and therefore could only store addresses 00 to FF. Therefore, CHIP-8 provides a special register that is used only to store memory addresses. This register, called the I register, proves useful when performing operations involving reading and writing to and from memory, most importantly, drawing graphics.
      iregister: 0,
      //The delay timer acts similarly to a data register: the programmer can load an eight bit value into the delay timer,
      // and read a value back later. The primary difference is that the delay timer perpetually
      // counts down at a rate of sixty hertz until it reaches zero.
      delay_timer: 0,
      instr: {
        // LD_6XNN - Store number NN in register VX
        LD_6XNN: function(hRegVX, hValue) { this.Parent.register[hex2dec(hRegVX)]=hex2dec(hValue); },
        // LD_8XY0 - Store the value of register VY in register VX
        LD_8XY0: function(hRegVX, hRegVY) { this.Parent.register[hex2dec(hRegVX)]=this.Parent.register[hex2dec(hRegVY)];  },
        // LD_ANNN - Store memory address NNN in register I
        LD_ANNN: function(hValue) {  this.Parent.iregister=hex2dec(hValue); },
        // LD_FX29 - Set I to the memory address of the sprite data corresponding to the hexadecimal digit stored in register VX
        LD_FX29: function(hRegVX) { this.Parent.iregister=this.Parent.register[ hex2dec(hRegVX) ]; },
        //LD_FX07 - Store the current value of the delay timer in register VX
        LD_FX07: function(hRegVX) { this.Parent.register[hex2dec(hRegVX)]=this.Parent.delay_timer; },
        // LD_FX15 - Set the delay timer to the value of register VX
        LD_FX15: function(hRegVX) { this.Parent.delay_timer=this.Parent.register[hex2dec(hRegVX)]; },

        // 7XNN Add the value NN to register VX
        ADD_7XNN: function(hReg, hValue) { this.Parent.register[hex2dec(hReg)] += hex2dec(hValue);
          if (this.Parent.register[hex2dec(hReg)]>255) {
            this.Parent.register[hex2dec(hReg)]= this.Parent.register[hex2dec(hReg)] % 256;
          }
        },
        // 8XY4 Add the value of register VY to register VX.
        // Set VF to 01 if a carry occurs. Set VF to 00 if a carry does not occur
        ADD_8XY4: function(valX, valY) {
          this.Parent.register[hex2dec(valX)]+=this.Parent.register[hex2dec(valY)];
          this.Parent.register[15]=0;
          if (this.Parent.register[hex2dec(valX)]>255) {
            this.Parent.register[hex2dec(valX)]=this.Parent.register[hex2dec(valX)] % 256;
            this.Parent.register[15]=1;
          }
        },
        //FX1E Add the value stored in register VX to register I
        ADD_FX1E: function(hReg) { this.Parent.iregister=this.Parent.register[hex2dec(hReg)]; },

        // SUB_8XY5 - Subtract the value of register VY from register VX.
        // Set VF to 00 if a borrow occurs. Set VF to 01 if a borrow does not occur"
        SUB_8XY5: function(hRegX,hRegY) {
          this.Parent.register[hex2dec(hRegX)] -= this.Parent.register[hex2dec(hRegY)];
          this.Parent.register[15]=1;
          if (this.Parent.register[hex2dec(hRegX)]<0) {
            this.Parent.register[hex2dec(hRegX)]=0;
            this.Parent.register[15]=0;
          }
        },
        // SUB_8XY7 - "Set register VX to the value of VY minus VX. Set VF to 00 if a borrow occurs.
        // Set VF to 01 if a borrow does not occur
        SUB_8XY7: function(hRegX,hRegY) {
          this.Parent.register[hex2dec(hRegX)] = this.Parent.register[hex2dec(hRegY)] - this.Parent.register[hex2dec(hRegX)];
          this.Parent.register[15]=1;
          if (this.Parent.register[hex2dec(hRegX)]<0) {
            this.Parent.register[hex2dec(hRegX)]=0;
            this.Parent.register[15]=0;
          }
        }

      },
      init: function() {
        this.instr.Parent = this;
          delete this.init;
          return this;
      }
    }.init();

    function hex2dec(hex) {
      return parseInt(hex, 16);
    }

    opcodes = {
          "00E0": [1, "CLS","Clear the screen"]
        , "00EE": [1, "RET","Return from a subroutine"]
        , "0NNN": [1, "SYS","Execute machine language subroutine at address NNN"]
        , "1NNN": [1, "JP","Jump to address NNN"]
        , "2NNN": [1, "CALL","Execute subroutine starting at address NNN"]
        , "3XNN": [1, "SE","Skip the following instruction if the value of register VX equals NN"]
        , "4XNN": [1, "SNE","Skip the following instruction if the value of register VX is not equal to NN"]
        , "5XY0": [1, "SE","Skip the following instruction if the value of register VX is equal to the value of register VY"]
        , "6XNN": [1, "LD","Store number NN in register VX"]
        , "7XNN": [1, "ADD","Add the value NN to register VX"]
        , "8XY0": [1, "LD","Store the value of register VY in register VX"]
        , "8XY1": [1, "OR","Set VX to VX OR VY"]
        , "8XY2": [1, "AND","Set VX to VX AND VY"]
        , "8XY3": [1, "XOR","Set VX to VX XOR VY"]
        , "8XY4": [1, "ADD","Add the value of register VY to register VX. Set VF to 01 if a carry occurs. Set VF to 00 if a carry does not occur"]
        , "8XY5": [1, "SUB","Subtract the value of register VY from register VX.Set VF to 00 if a borrow occurs. Set VF to 01 if a borrow does not occur"]
        , "8XY6": [1, "SHR","Store the value of register VY shifted right one bit in register VX. Set register VF to the least significant bit prior to the shift"]
        , "8XY7": [1, "SUB","Set register VX to the value of VY minus VX. Set VF to 00 if a borrow occurs. Set VF to 01 if a borrow does not occur"]
        , "8XYE": [1, "SHL","Store the value of register VY shifted left one bit in register VX. Set register VF to the most significant bit prior to the shift"]
        , "9XY0": [1, "SNE","Skip the following instruction if the value of register VX is not equal to the value of register VY"]
        , "ANNN": [1, "LD","Store memory address NNN in register I"]
        , "BNNN": [1, "JP","Jump to address NNN + V0"]
        , "CXNN": [1, "RND","Set VX to a random number with a mask of NN"]
        , "DXYN": [1, "DRW","Draw a sprite at position VX, VY with N bytes of sprite data starting at the address stored in I. Set VF to 01 if any set pixels are changed to unset, and 00 otherwise"]
        , "EX9E": [1, "SKP","Skip the following instruction if the key corresponding to the hex value currently stored in register VX is pressed"]
        , "EXA1": [1, "SKNP","Skip the following instruction if the key corresponding to the hex value currently stored in register VX is not pressed"]
        , "FX07": [1, "LD","Store the current value of the delay timer in register VX"]
        , "FX0A": [1, "LD","Wait for a keypress and store the result in register VX"]
        , "FX15": [1, "LD","Set the delay timer to the value of register VX"]
        , "FX18": [1, "LD","Set the sound timer to the value of register VX"]
        , "FX1E": [1, "ADD","Add the value stored in register VX to register I"]
        , "FX29": [1, "LD","Set I to the memory address of the sprite data corresponding to the hexadecimal digit stored in register VX"]
        , "FX33": [1, "LD","Store the binary-coded decimal equivalent of the value stored in register VX at addresses I, I+1, and I+2"]
        , "FX55": [1, "LD","Store the values of registers V0 to VX inclusive in memory starting at address I. I is set to I + X + 1 after operation"]
        , "FX65": [1, "LD","Fill registers V0 to VX inclusive with the values stored in memory starting at address I. I is set to I + X + 1 after operation"]
    }


    function main() {
      // setup gfx
      // setup input
      // init CHIP8_CPU
    }

    // the opcodes table is created for readability
    // now lets transpose for the sake of speed to a flat page
    const keys = Object.keys(opcodes);
    opcode_string=keys.toString();

    function debug_opcode(opcode, value) {
      console.log("[%s_%s] %s - %s", opcodes[opcode][1],  opcode, value, opcodes[opcode][2]);
    }

    function get_opcode_by_instr(instr) {
      //not going to use regex because regex would be a waste test if last-nibble is needed, the hard ways
      switch (instr[0]) {
        case '0':
           if (instr=="0000") {
             console.log("noop");
             return; // nop-cycle
           }
           // complex type.. test last-nibble
           switch (instr[3]) {
             case '0':
               debug_opcode("00E0",instr);
             break;
             case 'E': // 00EE
               debug_opcode("00EE",instr);
             break;
           }
          break;
        case '1':
          debug_opcode("1NNN",instr);
          break;
        case '2': // 2NNN
          debug_opcode("2NNN",instr);
          break;
        case '3': // 3XNN
          debug_opcode("3XNN",instr);
          break;
        case '4': // 4XNN
          debug_opcode("4XNN",instr);
          break;
        case '5': // 5XNN
          debug_opcode("5XNN",instr);
          break;
        case '6': // 6XNN
          debug_opcode("6XNN",instr);
          this.cpu.instr.LD_6XNN(instr[1],instr[2]+instr[3]);
          break;
        case '7': // 7XNN Add the value NN to register VX
          debug_opcode("7XNN",instr);
          this.cpu.instr.ADD_7XNN(instr[1],instr[2]+instr[3]);
          break;
        case '8':
          switch(instr[3]) {
            case '0': // 8XY0 Store the value of register VY in register VX
              debug_opcode("8XY0",instr);
              this.cpu.instr.LD_8XY0(instr[1],instr[2]);
              break;
            case '1': // 8XY1
              debug_opcode("8XY1",instr);
              break;
            case '2': // 8XY2
              debug_opcode("8XY2",instr);
              break;
            case '3': // 8XY3
              debug_opcode("8XY3",instr);
              break;
            case '4': // 8XY4 Add the value of register VY to register VX.
                      // Set VF to 01 if a carry occurs. Set VF to 00 if a carry does not occur
              debug_opcode("8XY4",instr);
              this.cpu.instr.ADD_8XY4(instr[1],instr[2]);
              break;
            case '5': // 8XY5
              // SUB","Subtract the value of register VY from register VX.
              // Set VF to 00 if a borrow occurs. Set VF to 01 if a borrow does not occur"
              debug_opcode("8XY5",instr);
              this.cpu.instr.SUB_8XY5(instr[1],instr[2]);
              break;
            case '6': // 8XY6
              debug_opcode("8XY6",instr);
              break;
            case '7': // SUB_8XY7 - "Set register VX to the value of VY minus VX. Set VF to 00 if a borrow occurs. Set VF to 01 if a borrow does not occur"]
              debug_opcode("8XY7",instr);
              this.cpu.instr.SUB_8XY7(instr[1],instr[2]);
              break;
            case '8': // 8XYE
              debug_opcode("8XYE",instr);
              break;
          }
          break;
        case '9': //9XY0
          debug_opcode("9XY0",instr);
          break;
        case 'A': //ANNN
          // Store memory address NNN in register I
          debug_opcode("ANNN",instr);
          this.cpu.instr.LD_ANNN(instr[1]+instr[2]+instr[3]);
          break;
        case 'B':  //BNNN
          debug_opcode("BNNN",instr);
          break;
        case 'C': //CXNN
          debug_opcode("CXNN",instr);
          break;
        case 'D': //DXYN
          debug_opcode("DXYN",instr);
          break;
        case 'E':
          switch (instr[3]) {
            case 'E': //EX9E
              debug_opcode("EX9E",instr);
              break;
            case '1': //EXA1
              debug_opcode("EXA1",instr);
              break;
          }
          break;
        case 'F':
          switch (instr[2]+instr[3]) {
            case '07': //FX07 Store the current value of the delay timer in register VX
              debug_opcode("FX07",instr);
              this.cpu.instr.LD_FX07(instr[1]);
              break;
            case '0A': //FX0A
              debug_opcode("FX0A",instr);
              break;
            case '15': // LD_FX15 - Set the delay timer to the value of register VX
              this.cpu.instr.LD_FX15(instr[1]);
              debug_opcode("FX15",instr);
              break;
            case '18': //FX18
              debug_opcode("FX18",instr);
              break;
            case '1E': //FX1E Add the value stored in register VX to register I
              debug_opcode("FX1E",instr);
              this.cpu.instr.ADD_FX1E(instr[1]);
              break;
            case '29': //FX29 Set I to the memory address of the sprite data corresponding to the hexadecimal digit stored in register VX
              debug_opcode("FX29",instr);
              this.cpu.instr.LD_FX29(instr[1]);
              break;
            case '33': //FX33
              debug_opcode("FX33",instr);
              break;
            case '55': //FX55
              debug_opcode("FX55",instr);
              break;
            case '65': //FX65
              debug_opcode("FX65",instr);
              break;
          }

          break;
      }
    }

    for (i=0;i<opcodes.keys;i++) {
      console.log( opcodes[i]);
    }

    var program = rom.data.toUpperCase().match(/(.{1,4})/g);
    for (i=0;i<program.length;i++) {
      get_opcode_by_instr(program[i]);
      // dump registers
      if (this.cpu.iregister>0) {
        console.log("iregister set to memory location: %s", this.cpu.iregister);
      }
      console.log( this.cpu.register);
    }

    </script>
  </head>
<body onload="javascript:main();">
http://mattmik.com/files/chip8/mastering/chip8.html
http://devernay.free.fr/hacks/chip8/C8TECH10.HTM
</body>
</html>
